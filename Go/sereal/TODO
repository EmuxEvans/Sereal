   TODO:
    - better test infrastructure: table-driven tests that use Perl's test cases
    - how do we handle hashes?
       : only string keys are supported -- do we call value.String() or panic()?
    - what other coersions (ints <-> strings)
    - add decoder and encoder options:
        string vs. byte array handling?
    - "header size" -> "optional header size"
    - roundtrip test: perl obj -> perl-sereal stream -> go1 obj -> go-sereal stream -> go2 obj, DeepEqual(go1, go2)
    - we should treat input buffer as read-only when unpacking
    - '5' == 'sereal-header-size'
    - lots of duplicatish code to remove:
           encodeArray/Ref and encodeMap/Ref should each be combined
           decode cases are similar too: array/ref, map/ref/ array/binary/short-binary
    - match 'ptr->array':ARRAYREF and 'ptr->hash':HASHREF
        - go can't do this in one-pass: we don't have ref counts
    - we use len() and generate HASHREF/ARRAYREF, other times HASH/ARRAY
       - (same with objects/structs)
    - class names need their own string table (for OBJECTV)
    - string table should have hash keys only (unless dedup strings is true?)
